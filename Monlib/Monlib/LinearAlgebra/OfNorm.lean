import LinearAlgebra.MyIps.Basic
import LinearAlgebra.MyIps.Ips
import LinearAlgebra.MyIps.RankOne
import Preq.IsROrCLe

#align_import linear_algebra.of_norm

open scoped ComplexOrder

section Ex4

variable {ùïú E : Type _} [IsROrC ùïú] [NormedAddCommGroup E] [InnerProductSpace ùïú E]

theorem cs_aux {x y : E} (hy : y ‚â† 0) :
    ‚Äñx - ((inner y x : ùïú) * (‚Äñy‚Äñ ^ 2)‚Åª¬π) ‚Ä¢ y‚Äñ ^ 2 = ‚Äñx‚Äñ ^ 2 - ‚Äñ(inner x y : ùïú)‚Äñ ^ 2 * (‚Äñy‚Äñ ^ 2)‚Åª¬π :=
  by
  have : ((‚Äñy‚Äñ ^ 2 : ‚Ñù) : ùïú) ‚â† 0 :=
    by
    rw [Ne.def, IsROrC.ofReal_eq_zero, sq_eq_zero_iff, norm_eq_zero]
    exact hy
  rw [‚Üê @inner_self_eq_norm_sq ùïú]
  simp only [inner_sub_sub_self, inner_smul_left, inner_smul_right, _root_.map_mul, inner_conj_symm,
    ‚Üê IsROrC.ofReal_pow]
  simp_rw [inner_self_eq_norm_sq_to_K, starRingEnd_apply, star_inv', IsROrC.star_def,
    IsROrC.conj_ofReal, mul_assoc, ‚Üê IsROrC.ofReal_pow, inv_mul_cancel this, mul_one]
  letI : InnerProductSpace.Core ùïú E := InnerProductSpace.toCore
  calc
    IsROrC.re
          (((‚Äñx‚Äñ ^ 2 : ‚Ñù) : ùïú) - (inner y x : ùïú) * (((‚Äñy‚Äñ ^ 2 : ‚Ñù) : ùïú)‚Åª¬π * (inner x y : ùïú)) -
              (inner x y : ùïú) * (((‚Äñy‚Äñ ^ 2 : ‚Ñù) : ùïú)‚Åª¬π * (inner y x : ùïú)) +
            (inner y x : ùïú) * (((‚Äñy‚Äñ ^ 2 : ‚Ñù) : ùïú)‚Åª¬π * (inner x y : ùïú))) =
        IsROrC.re (((‚Äñx‚Äñ ^ 2 : ‚Ñù) : ùïú) - (inner x y : ùïú) * (((‚Äñy‚Äñ ^ 2 : ‚Ñù) : ùïú)‚Åª¬π * inner y x)) :=
      _
    _ = IsROrC.re (‚Üë(‚Äñx‚Äñ ^ 2) - ‚Äñ(inner x y : ùïú)‚Äñ ^ 2 * (‚Üë(‚Äñy‚Äñ ^ 2))‚Åª¬π) := _
    _ = ‚Äñx‚Äñ ^ 2 - ‚Äñ(inner x y : ùïú)‚Äñ ^ 2 * (‚Äñy‚Äñ ^ 2)‚Åª¬π := _
  ¬∑ congr
    ring_nf
  ¬∑ rw [mul_rotate', ‚Üê inner_conj_symm, IsROrC.conj_mul, mul_comm, IsROrC.normSq_eq_def']
    simp_rw [_root_.map_sub, IsROrC.re_ofReal_mul]
    norm_cast
  ¬∑ norm_cast

-- already exists in `mathlib`... but different proof... just for fun
example {x y : E} (hx : x ‚â† 0) (hy : y ‚â† 0) :
    ‚Äñ(inner x y : ùïú)‚Äñ = ‚Äñx‚Äñ * ‚Äñy‚Äñ ‚Üî ‚àÉ Œ± : ùïúÀ£, x = (Œ± : ùïú) ‚Ä¢ y :=
  by
  constructor
  ¬∑ intro h
    have : (inner y x : ùïú) ‚â† 0 := by
      intro h'
      rw [inner_eq_zero_symm] at h'
      rw [h', norm_zero, eq_comm, mul_eq_zero] at h
      simp_rw [norm_eq_zero, hx, hy, false_or_iff] at h
      exact h
    have hy' : ‚Äñy‚Äñ ^ 2 ‚â† 0 := by
      rw [Ne.def, sq_eq_zero_iff, norm_eq_zero]
      exact hy
    rw [‚Üê sq_eq_sq (norm_nonneg _) (mul_nonneg (norm_nonneg _) (norm_nonneg _)), mul_pow, eq_comm, ‚Üê
      eq_mul_inv_iff_mul_eq‚ÇÄ hy', ‚Üê sub_eq_zero, ‚Üê cs_aux hy, sq_eq_zero_iff, norm_eq_zero,
      sub_eq_zero] at h
    exact
      ‚ü®Units.mk0 ((inner y x : ùïú) * ((‚Äñy‚Äñ : ùïú) ^ 2)‚Åª¬π)
          (mul_ne_zero this
            (by
              rw [Ne.def, inv_eq_zero, sq_eq_zero_iff, IsROrC.ofReal_eq_zero, norm_eq_zero]
              exact hy)),
        h‚ü©
  ¬∑ rintro ‚ü®Œ±, rfl‚ü©
    simp_rw [inner_smul_left, norm_mul, norm_smul, ‚Üê inner_self_re_eq_norm,
      inner_self_eq_norm_mul_norm, mul_assoc, IsROrC.norm_conj]

end Ex4

open IsROrC

open scoped ComplexConjugate

variable {ùïú X : Type _} [IsROrC ùïú] [NormedAddCommGroup X] [NormedSpace ùïú X]

noncomputable def OfNorm.innerDef (x y : X) : ùïú :=
  4‚Åª¬π * (‚Äñx + y‚Äñ ^ 2 - ‚Äñx - y‚Äñ ^ 2 + i * ‚Äñ(i : ùïú) ‚Ä¢ x + y‚Äñ ^ 2 - i * ‚Äñ(i : ùïú) ‚Ä¢ x - y‚Äñ ^ 2)

namespace OfNorm

theorem re_innerDef (x y : X) : re (innerDef x y : ùïú) = 4‚Åª¬π * (‚Äñx + y‚Äñ ^ 2 - ‚Äñx - y‚Äñ ^ 2) := by
  calc
    re (inner_def x y : ùïú) =
        re
          (4‚Åª¬π *
              (‚Äñx + y‚Äñ ^ 2 - ‚Äñx - y‚Äñ ^ 2 + I * ‚Äñ(I : ùïú) ‚Ä¢ x + y‚Äñ ^ 2 - I * ‚Äñ(I : ùïú) ‚Ä¢ x - y‚Äñ ^ 2) :
            ùïú) :=
      rfl
    _ =
        (4‚Åª¬π : ‚Ñù) *
          re
            (((‚Äñx + y‚Äñ ^ 2 - ‚Äñx - y‚Äñ ^ 2 : ‚Ñù) : ùïú) +
              I * ((‚Äñ(I : ùïú) ‚Ä¢ x + y‚Äñ ^ 2 - ‚Äñ(I : ùïú) ‚Ä¢ x - y‚Äñ ^ 2 : ‚Ñù) : ùïú)) :=
      by
      rw [mul_re]
      have : im (4 : ùïú)‚Åª¬π = 0 := by simp
      simp only [this, MulZeroClass.zero_mul, sub_zero, mul_sub, of_real_sub, of_real_pow]
      simp only [sub_eq_add_neg, add_assoc]
      congr
      ¬∑
        calc
          re (4 : ùïú)‚Åª¬π = re ((4 : ‚Ñù) : ùïú)‚Åª¬π := by
            congr
            norm_cast
          _ = (re ((4 : ‚Ñù) : ùïú))‚Åª¬π :=
            by
            simp_rw [inv_re, norm_sq_eq_def', norm_of_real]
            norm_num
          _ = (4 : ‚Ñù)‚Åª¬π := by simp only [of_real_re]
    _ = 4‚Åª¬π * (‚Äñx + y‚Äñ ^ 2 - ‚Äñx - y‚Äñ ^ 2) := by
      rw [_root_.map_add, I_mul_re, of_real_im, neg_zero, add_zero, of_real_re]

theorem im_eq_re_neg_i (x : ùïú) : im x = re (-(i : ùïú) * x) := by
  simp only [neg_mul, map_neg, I_mul_re, neg_neg]

theorem innerDef_zero_left (x : X) : (innerDef 0 x : ùïú) = 0 := by
  simp only [inner_def, smul_zero, zero_add, zero_sub, norm_neg, sub_self, MulZeroClass.mul_zero]

theorem innerDef_i_smul_left (x y : X) : (innerDef ((i : ùïú) ‚Ä¢ x) y : ùïú) = (-i : ùïú) * innerDef x y :=
  by
  by_cases hI : (I : ùïú) = 0
  ¬∑ simp_rw [hI, zero_smul, inner_def_zero_left, neg_zero, MulZeroClass.zero_mul]
  have hI' : (-I : ùïú) * I = 1 := by rw [‚Üê inv_I, inv_mul_cancel hI]
  simp only [inner_def, smul_eq_mul, ‚Üê mul_assoc, mul_comm (-I : ùïú) 4‚Åª¬π]
  simp only [mul_assoc]
  congr 1
  rw [smul_smul, I_mul_I_of_nonzero hI, neg_one_smul, neg_sub_left, norm_neg]
  simp only [mul_add, mul_sub]
  simp_rw [‚Üê mul_assoc, hI', one_mul, neg_mul]
  rw [sub_neg_eq_add]
  have : ‚Äñx - y‚Äñ = ‚Äñ-x + y‚Äñ := by rw [‚Üê norm_neg, neg_sub', sub_eq_add_neg, neg_neg]
  rw [this, add_comm x y]
  ring_nf

theorem im_innerDef_aux (x y : X) : im (innerDef x y : ùïú) = re (innerDef ((i : ùïú) ‚Ä¢ x) y : ùïú) := by
  rw [im_eq_re_neg_I, ‚Üê inner_def_I_smul_left]

theorem re_innerDef_symm (x y : X) : re (innerDef x y : ùïú) = re (innerDef y x : ùïú) :=
  by
  simp_rw [re_inner_def]
  rw [add_comm]
  congr 2
  simp only [sq_eq_sq, norm_nonneg, norm_sub_rev]

theorem im_innerDef_symm (x y : X) : im (innerDef x y : ùïú) = -im (innerDef y x : ùïú) :=
  by
  simp_rw [im_inner_def_aux]
  rw [re_inner_def_symm]
  by_cases (I : ùïú) = 0
  ¬∑
    simp only [re_inner_def, h, zero_smul, zero_add, add_zero, zero_sub, sub_zero, sub_self,
      norm_neg, MulZeroClass.mul_zero, neg_zero]
  ¬∑ have := norm_I_of_ne_zero h
    simp only [re_inner_def, ‚Üê neg_mul, neg_mul_comm]
    congr 1
    simp only [neg_sub]
    have h‚ÇÅ : ‚àÄ a : X, ‚Äña‚Äñ = ‚Äñ(I : ùïú) ‚Ä¢ a‚Äñ := fun a => by
      rw [norm_smul, norm_I_of_ne_zero h, one_mul]
    rw [h‚ÇÅ (y + (I : ùïú) ‚Ä¢ x), h‚ÇÅ (y - (I : ùïú) ‚Ä¢ x)]
    simp only [smul_add, smul_sub, smul_smul, I_mul_I_of_nonzero h, neg_one_smul]
    simp_rw [sub_eq_add_neg, neg_neg]

theorem innerDef_conj (x y : X) : conj (innerDef x y : ùïú) = innerDef y x :=
  by
  rw [‚Üê @re_add_im ùïú _ (inner_def x y)]
  simp_rw [map_add, map_mul, conj_of_real, conj_I]
  calc
    ‚Üë(re (inner_def x y : ùïú)) + ‚Üë(im (inner_def x y : ùïú)) * -(I : ùïú) =
        ‚Üë(re (inner_def y x : ùïú)) + ‚Üë(-im (inner_def x y : ùïú)) * (I : ùïú) :=
      by
      rw [re_inner_def_symm]
      congr 1
      simp
    _ = ‚Üë(re (inner_def y x : ùïú)) + ‚Üë(im (inner_def y x : ùïú)) * (I : ùïú) := by
      rw [‚Üê im_inner_def_symm]
    _ = inner_def y x := re_add_im _

section FromMathlib4

/-!
  In this section we show the addition property and scalar-multiplication property by mimicking (and copying) the `Mathlib4` code on `InnerProductSpace.ofNorm`.
-/


private theorem add_left_aux1
    (h : ‚àÄ x y : X, ‚Äñx + y‚Äñ * ‚Äñx + y‚Äñ + ‚Äñx - y‚Äñ * ‚Äñx - y‚Äñ = 2 * (‚Äñx‚Äñ * ‚Äñx‚Äñ + ‚Äñy‚Äñ * ‚Äñy‚Äñ))
    (x y z : X) :
    ‚Äñx + y + z‚Äñ * ‚Äñx + y + z‚Äñ =
      (‚Äñ2 ‚Ä¢ x + y‚Äñ * ‚Äñ2 ‚Ä¢ x + y‚Äñ + ‚Äñ2 ‚Ä¢ z + y‚Äñ * ‚Äñ2 ‚Ä¢ z + y‚Äñ) / 2 - ‚Äñx - z‚Äñ * ‚Äñx - z‚Äñ :=
  by
  rw [eq_sub_iff_add_eq, eq_div_iff (two_ne_zero' ‚Ñù), mul_comm _ (2 : ‚Ñù), eq_comm]
  convert h (x + y + z) (x - z) using 4
  all_goals rw [two_smul]; abel

private theorem add_left_aux2
    (h : ‚àÄ x y : X, ‚Äñx + y‚Äñ * ‚Äñx + y‚Äñ + ‚Äñx - y‚Äñ * ‚Äñx - y‚Äñ = 2 * (‚Äñx‚Äñ * ‚Äñx‚Äñ + ‚Äñy‚Äñ * ‚Äñy‚Äñ))
    (x y z : X) :
    ‚Äñx + y - z‚Äñ * ‚Äñx + y - z‚Äñ =
      (‚Äñ2 ‚Ä¢ x + y‚Äñ * ‚Äñ2 ‚Ä¢ x + y‚Äñ + ‚Äñy - 2 ‚Ä¢ z‚Äñ * ‚Äñy - 2 ‚Ä¢ z‚Äñ) / 2 - ‚Äñx + z‚Äñ * ‚Äñx + z‚Äñ :=
  by
  rw [eq_sub_iff_add_eq, eq_div_iff (two_ne_zero' ‚Ñù), mul_comm _ (2 : ‚Ñù), eq_comm]
  have h‚ÇÄ := h (x + y - z) (x + z)
  convert h‚ÇÄ using 4
  all_goals rw [two_smul]; abel

private theorem add_left_aux2'
    (h : ‚àÄ x y : X, ‚Äñx + y‚Äñ * ‚Äñx + y‚Äñ + ‚Äñx - y‚Äñ * ‚Äñx - y‚Äñ = 2 * (‚Äñx‚Äñ * ‚Äñx‚Äñ + ‚Äñy‚Äñ * ‚Äñy‚Äñ))
    (x y z : X) :
    ‚Äñx + y + z‚Äñ * ‚Äñx + y + z‚Äñ - ‚Äñx + y - z‚Äñ * ‚Äñx + y - z‚Äñ =
      ‚Äñx + z‚Äñ * ‚Äñx + z‚Äñ - ‚Äñx - z‚Äñ * ‚Äñx - z‚Äñ +
        (‚Äñ2 ‚Ä¢ z + y‚Äñ * ‚Äñ2 ‚Ä¢ z + y‚Äñ - ‚Äñy - 2 ‚Ä¢ z‚Äñ * ‚Äñy - 2 ‚Ä¢ z‚Äñ) / 2 :=
  by rw [add_left_aux1 h, add_left_aux2 h] <;> ring

private theorem add_left_aux3
    (h : ‚àÄ x y : X, ‚Äñx + y‚Äñ * ‚Äñx + y‚Äñ + ‚Äñx - y‚Äñ * ‚Äñx - y‚Äñ = 2 * (‚Äñx‚Äñ * ‚Äñx‚Äñ + ‚Äñy‚Äñ * ‚Äñy‚Äñ)) (y z : X) :
    ‚Äñ2 ‚Ä¢ z + y‚Äñ * ‚Äñ2 ‚Ä¢ z + y‚Äñ = 2 * (‚Äñy + z‚Äñ * ‚Äñy + z‚Äñ + ‚Äñz‚Äñ * ‚Äñz‚Äñ) - ‚Äñy‚Äñ * ‚Äñy‚Äñ :=
  by
  apply eq_sub_of_add_eq
  convert h (y + z) z using 4
  all_goals try rw [two_smul]; abel

private theorem add_left_aux4
    (h : ‚àÄ x y : X, ‚Äñx + y‚Äñ * ‚Äñx + y‚Äñ + ‚Äñx - y‚Äñ * ‚Äñx - y‚Äñ = 2 * (‚Äñx‚Äñ * ‚Äñx‚Äñ + ‚Äñy‚Äñ * ‚Äñy‚Äñ)) (y z : X) :
    ‚Äñy - 2 ‚Ä¢ z‚Äñ * ‚Äñy - 2 ‚Ä¢ z‚Äñ = 2 * (‚Äñy - z‚Äñ * ‚Äñy - z‚Äñ + ‚Äñz‚Äñ * ‚Äñz‚Äñ) - ‚Äñy‚Äñ * ‚Äñy‚Äñ :=
  by
  apply eq_sub_of_add_eq'
  have h‚ÇÄ := h (y - z) z
  convert h‚ÇÄ using 4
  all_goals try rw [two_smul]; abel

private theorem add_left_aux4'
    (h : ‚àÄ x y : X, ‚Äñx + y‚Äñ * ‚Äñx + y‚Äñ + ‚Äñx - y‚Äñ * ‚Äñx - y‚Äñ = 2 * (‚Äñx‚Äñ * ‚Äñx‚Äñ + ‚Äñy‚Äñ * ‚Äñy‚Äñ)) (y z : X) :
    (‚Äñ2 ‚Ä¢ z + y‚Äñ * ‚Äñ2 ‚Ä¢ z + y‚Äñ - ‚Äñy - 2 ‚Ä¢ z‚Äñ * ‚Äñy - 2 ‚Ä¢ z‚Äñ) / 2 =
      ‚Äñy + z‚Äñ * ‚Äñy + z‚Äñ - ‚Äñy - z‚Äñ * ‚Äñy - z‚Äñ :=
  by rw [add_left_aux3 h, add_left_aux4 h] <;> ring

private theorem add_left_aux5
    (h : ‚àÄ x y : X, ‚Äñx + y‚Äñ * ‚Äñx + y‚Äñ + ‚Äñx - y‚Äñ * ‚Äñx - y‚Äñ = 2 * (‚Äñx‚Äñ * ‚Äñx‚Äñ + ‚Äñy‚Äñ * ‚Äñy‚Äñ))
    (x y z : X) :
    ‚Äñ(i : ùïú) ‚Ä¢ (x + y) + z‚Äñ * ‚Äñ(i : ùïú) ‚Ä¢ (x + y) + z‚Äñ =
      (‚Äñ(i : ùïú) ‚Ä¢ (2 ‚Ä¢ x + y)‚Äñ * ‚Äñ(i : ùïú) ‚Ä¢ (2 ‚Ä¢ x + y)‚Äñ +
            ‚Äñ(i : ùïú) ‚Ä¢ y + 2 ‚Ä¢ z‚Äñ * ‚Äñ(i : ùïú) ‚Ä¢ y + 2 ‚Ä¢ z‚Äñ) /
          2 -
        ‚Äñ(i : ùïú) ‚Ä¢ x - z‚Äñ * ‚Äñ(i : ùïú) ‚Ä¢ x - z‚Äñ :=
  by
  rw [eq_sub_iff_add_eq, eq_div_iff (two_ne_zero' ‚Ñù), mul_comm _ (2 : ‚Ñù), eq_comm]
  have h‚ÇÄ := h ((I : ùïú) ‚Ä¢ (x + y) + z) ((I : ùïú) ‚Ä¢ x - z)
  convert h‚ÇÄ using 4
  all_goals try simp only [two_smul, smul_add]; abel

private theorem add_left_aux6
    (h : ‚àÄ x y : X, ‚Äñx + y‚Äñ * ‚Äñx + y‚Äñ + ‚Äñx - y‚Äñ * ‚Äñx - y‚Äñ = 2 * (‚Äñx‚Äñ * ‚Äñx‚Äñ + ‚Äñy‚Äñ * ‚Äñy‚Äñ))
    (x y z : X) :
    ‚Äñ(i : ùïú) ‚Ä¢ (x + y) - z‚Äñ * ‚Äñ(i : ùïú) ‚Ä¢ (x + y) - z‚Äñ =
      (‚Äñ(i : ùïú) ‚Ä¢ (2 ‚Ä¢ x + y)‚Äñ * ‚Äñ(i : ùïú) ‚Ä¢ (2 ‚Ä¢ x + y)‚Äñ +
            ‚Äñ(i : ùïú) ‚Ä¢ y - 2 ‚Ä¢ z‚Äñ * ‚Äñ(i : ùïú) ‚Ä¢ y - 2 ‚Ä¢ z‚Äñ) /
          2 -
        ‚Äñ(i : ùïú) ‚Ä¢ x + z‚Äñ * ‚Äñ(i : ùïú) ‚Ä¢ x + z‚Äñ :=
  by
  rw [eq_sub_iff_add_eq, eq_div_iff (two_ne_zero' ‚Ñù), mul_comm _ (2 : ‚Ñù), eq_comm]
  have h‚ÇÄ := h ((I : ùïú) ‚Ä¢ (x + y) - z) ((I : ùïú) ‚Ä¢ x + z)
  convert h‚ÇÄ using 4
  all_goals try simp only [two_smul, smul_add]; abel

private theorem add_left_aux7
    (h : ‚àÄ x y : X, ‚Äñx + y‚Äñ * ‚Äñx + y‚Äñ + ‚Äñx - y‚Äñ * ‚Äñx - y‚Äñ = 2 * (‚Äñx‚Äñ * ‚Äñx‚Äñ + ‚Äñy‚Äñ * ‚Äñy‚Äñ)) (y z : X) :
    ‚Äñ(i : ùïú) ‚Ä¢ y + 2 ‚Ä¢ z‚Äñ * ‚Äñ(i : ùïú) ‚Ä¢ y + 2 ‚Ä¢ z‚Äñ =
      2 * (‚Äñ(i : ùïú) ‚Ä¢ y + z‚Äñ * ‚Äñ(i : ùïú) ‚Ä¢ y + z‚Äñ + ‚Äñz‚Äñ * ‚Äñz‚Äñ) - ‚Äñ(i : ùïú) ‚Ä¢ y‚Äñ * ‚Äñ(i : ùïú) ‚Ä¢ y‚Äñ :=
  by
  apply eq_sub_of_add_eq
  have h‚ÇÄ := h ((I : ùïú) ‚Ä¢ y + z) z
  convert h‚ÇÄ using 4
  all_goals try simp only [two_smul, smul_add]; abel

private theorem add_left_aux8
    (h : ‚àÄ x y : X, ‚Äñx + y‚Äñ * ‚Äñx + y‚Äñ + ‚Äñx - y‚Äñ * ‚Äñx - y‚Äñ = 2 * (‚Äñx‚Äñ * ‚Äñx‚Äñ + ‚Äñy‚Äñ * ‚Äñy‚Äñ)) (y z : X) :
    ‚Äñ(i : ùïú) ‚Ä¢ y - 2 ‚Ä¢ z‚Äñ * ‚Äñ(i : ùïú) ‚Ä¢ y - 2 ‚Ä¢ z‚Äñ =
      2 * (‚Äñ(i : ùïú) ‚Ä¢ y - z‚Äñ * ‚Äñ(i : ùïú) ‚Ä¢ y - z‚Äñ + ‚Äñz‚Äñ * ‚Äñz‚Äñ) - ‚Äñ(i : ùïú) ‚Ä¢ y‚Äñ * ‚Äñ(i : ùïú) ‚Ä¢ y‚Äñ :=
  by
  apply eq_sub_of_add_eq'
  have h‚ÇÄ := h ((I : ùïú) ‚Ä¢ y - z) z
  convert h‚ÇÄ using 4
  all_goals try simp only [two_smul, smul_add]; abel

theorem innerDef_add_left
    (h : ‚àÄ x y : X, ‚Äñx + y‚Äñ * ‚Äñx + y‚Äñ + ‚Äñx - y‚Äñ * ‚Äñx - y‚Äñ = 2 * (‚Äñx‚Äñ * ‚Äñx‚Äñ + ‚Äñy‚Äñ * ‚Äñy‚Äñ))
    (x y z : X) : (innerDef (x + y) z : ùïú) = innerDef x z + innerDef y z :=
  by
  simp only [inner_def, ‚Üê mul_add]
  congr
  simp only [mul_assoc, ‚Üê map_mul, add_sub_assoc, ‚Üê mul_sub, ‚Üê map_sub]
  rw [add_add_add_comm]
  simp only [‚Üê map_add, ‚Üê mul_add, pow_two, ‚Üê of_real_mul, ‚Üê of_real_sub, ‚Üê of_real_add]
  congr
  ¬∑ rw [‚Üê add_sub_assoc, add_left_aux2' h x y z, add_left_aux4' h]
  ¬∑ rw [add_sub]
    by_cases h‚ÇÄ : (I : ùïú) = 0
    ¬∑ simp only [h‚ÇÄ, zero_smul, zero_add, zero_sub, sub_self, norm_neg]
    ¬∑ have h‚ÇÄ‚ÇÄ := I_mul_I_of_nonzero h‚ÇÄ
      have h‚ÇÄ‚ÇÅ := norm_I_of_ne_zero h‚ÇÄ
      rw [add_left_aux5 h, add_left_aux6 h, add_left_aux7 h, add_left_aux8 h]
      simp only [map_sub, map_mul, map_add, div_eq_mul_inv]
      ring_nf

theorem innerDef_nsmul_left
    (h : ‚àÄ x y : X, ‚Äñx + y‚Äñ * ‚Äñx + y‚Äñ + ‚Äñx - y‚Äñ * ‚Äñx - y‚Äñ = 2 * (‚Äñx‚Äñ * ‚Äñx‚Äñ + ‚Äñy‚Äñ * ‚Äñy‚Äñ)) (n : ‚Ñï)
    (x y : X) : innerDef ((n : ùïú) ‚Ä¢ x) y = (n : ùïú) * innerDef x y :=
  by
  induction' n with n hd
  ¬∑
    simp only [inner_def, zero_sub, Nat.cast_zero, MulZeroClass.zero_mul, eq_self_iff_true,
      zero_smul, zero_add, MulZeroClass.mul_zero, sub_self, norm_neg, smul_zero]
  ¬∑ simp only [Nat.cast_succ, add_smul, one_smul, add_mul, one_mul]
    rw [‚Üê hd, ‚Üê inner_def_add_left h]

theorem innerDef_neg_one_smul_left (x y : X) :
    (innerDef (((-1 : ‚Ñ§) : ùïú) ‚Ä¢ x) y : ùïú) = -innerDef x y :=
  by
  simp only [inner_def, neg_mul_eq_neg_mul, one_mul, Int.cast_one, one_smul, RingHom.map_one,
    map_neg, Int.cast_neg, neg_smul, neg_one_mul]
  rw [neg_mul_comm]
  congr 1
  have h‚ÇÅ : ‚Äñ-x - y‚Äñ = ‚Äñx + y‚Äñ := by rw [‚Üê neg_add', norm_neg]
  have h‚ÇÇ : ‚Äñ-x + y‚Äñ = ‚Äñx - y‚Äñ := by rw [‚Üê neg_sub, norm_neg, sub_eq_neg_add]
  have h‚ÇÉ : ‚Äñ(I : ùïú) ‚Ä¢ -x + y‚Äñ = ‚Äñ(I : ùïú) ‚Ä¢ x - y‚Äñ := by
    rw [‚Üê neg_sub, norm_neg, sub_eq_neg_add, ‚Üê smul_neg]
  have h‚ÇÑ : ‚Äñ(I : ùïú) ‚Ä¢ -x - y‚Äñ = ‚Äñ(I : ùïú) ‚Ä¢ x + y‚Äñ := by rw [smul_neg, ‚Üê neg_add', norm_neg]
  rw [h‚ÇÅ, h‚ÇÇ, h‚ÇÉ, h‚ÇÑ]
  ring

private theorem inner_def_zsmul_left
    (h : ‚àÄ x y : X, ‚Äñx + y‚Äñ * ‚Äñx + y‚Äñ + ‚Äñx - y‚Äñ * ‚Äñx - y‚Äñ = 2 * (‚Äñx‚Äñ * ‚Äñx‚Äñ + ‚Äñy‚Äñ * ‚Äñy‚Äñ)) (n : ‚Ñ§)
    (x y : X) : innerDef ((n : ùïú) ‚Ä¢ x) y = (n : ùïú) * innerDef x y :=
  by
  rw [‚Üê n.sign_mul_nat_abs]
  simp only [Int.cast_ofNat, map_natCast, map_intCast, Int.cast_mul, map_mul, mul_smul]
  obtain hn | rfl | hn := lt_trichotomy n 0
  ¬∑ rw [Int.sign_eq_neg_one_of_neg hn, inner_def_neg_one_smul_left, Int.cast_ofNat,
      inner_def_nsmul_left h n.nat_abs]
    simp only [Int.cast_one, Int.cast_neg, neg_one_mul, neg_mul, one_mul]
  ¬∑ simp [inner_def_zero_left]
  ¬∑ rw [Int.sign_eq_one_of_pos hn]
    simp only [Int.cast_one, one_smul, one_mul, Int.cast_ofNat, inner_def_nsmul_left h]

private theorem inner_def_rat_smul_left
    (h : ‚àÄ x y : X, ‚Äñx + y‚Äñ * ‚Äñx + y‚Äñ + ‚Äñx - y‚Äñ * ‚Äñx - y‚Äñ = 2 * (‚Äñx‚Äñ * ‚Äñx‚Äñ + ‚Äñy‚Äñ * ‚Äñy‚Äñ)) (r : ‚Ñö)
    (x y : X) : (innerDef ((r : ùïú) ‚Ä¢ x) y : ùïú) = (r : ùïú) ‚Ä¢ innerDef x y :=
  by
  have : (r.denom : ùïú) ‚â† 0 :=
    by
    haveI : CharZero ùïú := IsROrC.charZero_isROrC
    norm_cast
    exact r.pos.ne'
  rw [‚Üê r.num_div_denom, ‚Üê mul_right_inj' this, Rat.cast_div]
  simp only [map_natCast, Rat.cast_coe_nat, map_intCast, Rat.cast_coe_int, map_div‚ÇÄ]
  simp_rw [div_eq_mul_inv, ‚Üê smul_smul, inner_def_zsmul_left h]
  rw [‚Üê mul_assoc, mul_comm ‚Üër.denom _, mul_assoc, ‚Üê inner_def_nsmul_left h]
  simp [smul_smul, ‚Üê mul_assoc]
  rw [mul_rotate ‚Üër.denom]
  simp only [mul_assoc]
  congr 1
  simp only [‚Üê mul_assoc, inv_mul_cancel this, mul_inv_cancel this, one_smul, one_mul]

theorem Continuous.innerDef {f g : ‚Ñù ‚Üí X} (hf : Continuous f) (hg : Continuous g) :
    Continuous fun x : ‚Ñù => (innerDef (f x) (g x) : ùïú) :=
  by
  unfold inner_def
  continuity

private theorem inner_def_rsmul_left
    (h : ‚àÄ x y : X, ‚Äñx + y‚Äñ * ‚Äñx + y‚Äñ + ‚Äñx - y‚Äñ * ‚Äñx - y‚Äñ = 2 * (‚Äñx‚Äñ * ‚Äñx‚Äñ + ‚Äñy‚Äñ * ‚Äñy‚Äñ)) (r : ‚Ñù)
    (x y : X) : innerDef ((r : ùïú) ‚Ä¢ x) y = (r : ùïú) * innerDef x y :=
  by
  revert r
  rw [‚Üê Function.funext_iff]
  refine' rat.dense_embedding_coe_real.dense.equalizer _ _ (funext fun _ => _)
  ¬∑ exact (continuous_of_real.smul continuous_const).innerDef continuous_const
  ¬∑ continuity
  ¬∑ simp only [Function.comp_apply, IsROrC.ofReal_ratCast, inner_def_rat_smul_left h]
    rfl

theorem innerDef_smul_left
    (h : ‚àÄ x y : X, ‚Äñx + y‚Äñ * ‚Äñx + y‚Äñ + ‚Äñx - y‚Äñ * ‚Äñx - y‚Äñ = 2 * (‚Äñx‚Äñ * ‚Äñx‚Äñ + ‚Äñy‚Äñ * ‚Äñy‚Äñ)) (r : ùïú)
    (x y : X) : innerDef (r ‚Ä¢ x) y = conj r * innerDef x y :=
  by
  rw [‚Üê re_add_im r, add_smul, inner_def_add_left h, inner_def_rsmul_left h, ‚Üê smul_smul,
    inner_def_rsmul_left h, inner_def_I_smul_left, map_add, map_mul, conj_of_real, conj_of_real,
    conj_I]
  ring

/-!
 End of section from `Mathlib4`.
-/


end FromMathlib4

noncomputable def InnerProductSpacce.ofNorm
    (h : ‚àÄ x y : X, ‚Äñx + y‚Äñ * ‚Äñx + y‚Äñ + ‚Äñx - y‚Äñ * ‚Äñx - y‚Äñ = 2 * (‚Äñx‚Äñ * ‚Äñx‚Äñ + ‚Äñy‚Äñ * ‚Äñy‚Äñ)) :
    InnerProductSpace ùïú X where
  inner x y := innerDef x y
  norm_sq_eq_inner x := by
    simp only [inner, re_inner_def, pow_two]
    specialize h x x
    simp only [sub_self, norm_zero, MulZeroClass.zero_mul, sub_zero, add_zero] at h ‚ä¢
    simp only [h, ‚Üê two_mul, ‚Üê mul_assoc]
    norm_num
  conj_symm x y := innerDef_conj y x
  add_left x y z := innerDef_add_left h _ _ _
  smul_left r x y := innerDef_smul_left h _ _ _

end OfNorm

open scoped ComplexConjugate

def IsContinuousLinearMap (ùïú : Type _) [NormedField ùïú] {E : Type _} [NormedAddCommGroup E]
    [NormedSpace ùïú E] {F : Type _} [NormedAddCommGroup F] [NormedSpace ùïú F] (f : E ‚Üí F) : Prop :=
  IsLinearMap ùïú f ‚àß Continuous f

def IsContinuousLinearMap.mk' {ùïú : Type _} [NormedField ùïú] {E : Type _} [NormedAddCommGroup E]
    [NormedSpace ùïú E] {F : Type _} [NormedAddCommGroup F] [NormedSpace ùïú F] {f : E ‚Üí F}
    (h : IsContinuousLinearMap ùïú f) : E ‚ÜíL[ùïú] F :=
  ‚ü®h.1.mk' f, h.2‚ü©

theorem IsContinuousLinearMap.coe_mk' {ùïú : Type _} [NormedField ùïú] {E : Type _}
    [NormedAddCommGroup E] [NormedSpace ùïú E] {F : Type _} [NormedAddCommGroup F] [NormedSpace ùïú F]
    {f : E ‚Üí F} (h : IsContinuousLinearMap ùïú f) : f = h.mk' :=
  rfl

theorem isBoundedLinearMap_iff_isContinuousLinearMap {ùïú E : Type _} [NontriviallyNormedField ùïú]
    [NormedAddCommGroup E] [NormedSpace ùïú E] {F : Type _} [NormedAddCommGroup F] [NormedSpace ùïú F]
    (f : E ‚Üí F) : IsBoundedLinearMap ùïú f ‚Üî IsContinuousLinearMap ùïú f :=
  by
  refine'
    ‚ü®fun h => ‚ü®IsBoundedLinearMap.to_isLinearMap h, IsBoundedLinearMap.continuous h‚ü©, fun h => _‚ü©
  let f' : E ‚ÜíL[ùïú] F := ‚ü®h.1.mk' f, h.2‚ü©
  exact f'.is_bounded_linear_map

private theorem linear_map.is_bounded_linear_map_iff_is_continuous {ùïú E : Type _}
    [NontriviallyNormedField ùïú] [NormedAddCommGroup E] [NormedSpace ùïú E] {F : Type _}
    [NormedAddCommGroup F] [NormedSpace ùïú F] (f : E ‚Üí‚Çó[ùïú] F) :
    IsBoundedLinearMap ùïú f ‚Üî Continuous f :=
  by
  rw [isBoundedLinearMap_iff_isContinuousLinearMap, IsContinuousLinearMap]
  simp only [and_iff_right_iff_imp, f.is_linear, imp_true_iff]

def WithBound {E : Type _} [NormedAddCommGroup E] {F : Type _} [NormedAddCommGroup F] (f : E ‚Üí F) :
    Prop :=
  ‚àÉ M, 0 < M ‚àß ‚àÄ x : E, ‚Äñf x‚Äñ ‚â§ M * ‚Äñx‚Äñ

theorem IsBoundedLinearMap.def {ùïú E : Type _} [NontriviallyNormedField ùïú] [NormedAddCommGroup E]
    [NormedSpace ùïú E] {F : Type _} [NormedAddCommGroup F] [NormedSpace ùïú F] {f : E ‚Üí F} :
    IsBoundedLinearMap ùïú f ‚Üî IsLinearMap ùïú f ‚àß WithBound f :=
  ‚ü®fun h => ‚ü®h.1, h.2‚ü©, fun h => ‚ü®h.1, h.2‚ü©‚ü©

theorem LinearMap.withBound_iff_is_continuous {ùïú E : Type _} [NontriviallyNormedField ùïú]
    [NormedAddCommGroup E] [NormedSpace ùïú E] {F : Type _} [NormedAddCommGroup F] [NormedSpace ùïú F]
    {f : E ‚Üí‚Çó[ùïú] F} : WithBound f ‚Üî Continuous f :=
  by
  have := @isBoundedLinearMap_iff_isContinuousLinearMap ùïú _ _ _ _ _ _ _ f
  simp only [IsBoundedLinearMap.def, IsContinuousLinearMap, and_congr_right_iff, f.is_linear,
    true_imp_iff] at this
  exact this

theorem LinearMap.ker_coe_def {R E F : Type _} [Semiring R] [AddCommMonoid E] [AddCommMonoid F]
    [Module R E] [Module R F] {f : E ‚Üí‚Çó[R] F} : (f.ker : Set E) = {x : E | f x = 0} :=
  rfl

theorem exists_dual_vector_of_ne {X : Type _} [NormedAddCommGroup X] [NormedSpace ùïú X] {x y : X}
    (h : x ‚â† y) : ‚àÉ f : NormedSpace.Dual ùïú X, f x ‚â† f y :=
  by
  rw [Ne.def, ‚Üê sub_eq_zero] at h
  obtain ‚ü®f, ‚ü®hf, hxy‚ü©‚ü© := @exists_dual_vector ùïú _ X _ _ _ h
  rw [map_sub] at hxy
  use f
  intro H
  rw [H, sub_self, eq_comm, IsROrC.ofReal_eq_zero, norm_eq_zero] at hxy
  contradiction

theorem isLinearMap_zero (R : Type _) {E F : Type _} [CommSemiring R] [AddCommMonoid E] [Module R E]
    [AddCommMonoid F] [Module R F] : IsLinearMap R (0 : E ‚Üí F) := by
  fconstructor <;> simp only [Pi.zero_apply, smul_zero, add_zero] <;> intros <;> trivial

theorem isContinuousLinearMapZero {ùïú E : Type _} [NormedField ùïú] [NormedAddCommGroup E]
    [NormedSpace ùïú E] {F : Type _} [NormedAddCommGroup F] [NormedSpace ùïú F] :
    IsContinuousLinearMap ùïú (0 : E ‚Üí F) :=
  ‚ü®isLinearMap_zero ùïú, continuous_zero‚ü©

open scoped Classical Topology BigOperators NNReal

theorem IsContinuousLinearMap.ofInnerSymmetricFun {X : Type _} [NormedAddCommGroup X]
    [InnerProductSpace ùïú X] [CompleteSpace X] {f : X ‚Üí X}
    (h : ‚àÄ a b : X, (inner (f a) b : ùïú) = inner a (f b)) : IsContinuousLinearMap ùïú f :=
  by
  have : IsLinearMap ùïú f :=
    { map_add := fun x y => by
        apply @ext_inner_right ùïú
        intro z
        simp_rw [h, inner_add_left, h]
      map_smul := fun r x => by
        apply @ext_inner_right ùïú
        intro z
        simp_rw [h, inner_smul_left, h] }
  let f' : X ‚Üí‚Çó[ùïú] X := IsLinearMap.mk' _ this
  have : f = f' := rfl
  simp only [this] at *
  clear this
  exact ‚ü®f'.is_linear, LinearMap.IsSymmetric.continuous h‚ü©

structure IsBilinearMap (ùïú : Type _) [NormedField ùïú] {E : Type _} [NormedAddCommGroup E]
    [NormedSpace ùïú E] {F : Type _} [NormedAddCommGroup F] [NormedSpace ùïú F] {G : Type _}
    [NormedAddCommGroup G] [NormedSpace ùïú G] (f : E √ó F ‚Üí G) : Prop where
  add_left : ‚àÄ (x‚ÇÅ x‚ÇÇ : E) (y : F), f (x‚ÇÅ + x‚ÇÇ, y) = f (x‚ÇÅ, y) + f (x‚ÇÇ, y)
  smul_left : ‚àÄ (c : ùïú) (x : E) (y : F), f (c ‚Ä¢ x, y) = c ‚Ä¢ f (x, y)
  add_right : ‚àÄ (x : E) (y‚ÇÅ y‚ÇÇ : F), f (x, y‚ÇÅ + y‚ÇÇ) = f (x, y‚ÇÅ) + f (x, y‚ÇÇ)
  smul_right : ‚àÄ (c : ùïú) (x : E) (y : F), f (x, c ‚Ä¢ y) = c ‚Ä¢ f (x, y)

def IsLeftLinearMap (ùïú : Type _) [NormedField ùïú] {E : Type _} [NormedAddCommGroup E]
    [NormedSpace ùïú E] {F : Type _} {G : Type _} [NormedAddCommGroup G] [NormedSpace ùïú G]
    (f : E √ó F ‚Üí G) : Prop :=
  ‚àÄ b : F, IsLinearMap ùïú fun a => f (a, b)

theorem isLeftLinearMap_iff {ùïú : Type _} [NormedField ùïú] {E : Type _} [NormedAddCommGroup E]
    [NormedSpace ùïú E] {F : Type _} {G : Type _} [NormedAddCommGroup G] [NormedSpace ùïú G]
    {f : E √ó F ‚Üí G} : IsLeftLinearMap ùïú f ‚Üî ‚àÄ b : F, IsLinearMap ùïú fun a => f (a, b) :=
  Iff.rfl

def IsRightLinearMap (ùïú : Type _) [NormedField ùïú] {E : Type _} {F : Type _} [NormedAddCommGroup F]
    [NormedSpace ùïú F] {G : Type _} [NormedAddCommGroup G] [NormedSpace ùïú G] (f : E √ó F ‚Üí G) :
    Prop :=
  ‚àÄ a : E, IsLinearMap ùïú fun b => f (a, b)

theorem isRightLinearMap_iff {ùïú : Type _} [NormedField ùïú] {E : Type _} {F : Type _}
    [NormedAddCommGroup F] [NormedSpace ùïú F] {G : Type _} [NormedAddCommGroup G] [NormedSpace ùïú G]
    {f : E √ó F ‚Üí G} : IsRightLinearMap ùïú f ‚Üî ‚àÄ a : E, IsLinearMap ùïú fun b => f (a, b) :=
  Iff.rfl

theorem isBilinearMap_iff_is_linear_map_left_right {ùïú : Type _} [NormedField ùïú] {E : Type _}
    [NormedAddCommGroup E] [NormedSpace ùïú E] {F : Type _} [NormedAddCommGroup F] [NormedSpace ùïú F]
    {G : Type _} [NormedAddCommGroup G] [NormedSpace ùïú G] {f : E √ó F ‚Üí G} :
    IsBilinearMap ùïú f ‚Üî IsLeftLinearMap ùïú f ‚àß IsRightLinearMap ùïú f :=
  by
  constructor
  ¬∑ intro hf
    constructor
    ¬∑ intro x
      exact ‚ü®fun y z => hf.add_left y z x, fun r a => hf.smul_left r a x‚ü©
    ¬∑ intro x
      exact ‚ü®fun y z => hf.add_right x y z, fun r a => hf.smul_right r x a‚ü©
  ¬∑ rintro ‚ü®h1, h2‚ü©
    fconstructor
    ¬∑ intro x‚ÇÅ x‚ÇÇ y
      exact (h1 y).map_add _ _
    ¬∑ intro r x y
      exact (h1 y).map_smul _ _
    ¬∑ intro y x‚ÇÅ x‚ÇÇ
      exact (h2 y).map_add _ _
    ¬∑ intro r x y
      exact (h2 x).map_smul _ _

def IsBilinearMap.toLmLm {ùïú : Type _} [NormedField ùïú] {E : Type _} [NormedAddCommGroup E]
    [NormedSpace ùïú E] {F : Type _} [NormedAddCommGroup F] [NormedSpace ùïú F] {G : Type _}
    [NormedAddCommGroup G] [NormedSpace ùïú G] {f : E √ó F ‚Üí G} (hf : IsBilinearMap ùïú f) :
    E ‚Üí‚Çó[ùïú] F ‚Üí‚Çó[ùïú] G
    where
  toFun x :=
    { toFun := fun y => f (x, y)
      map_add' := fun y z => hf.add_right x _ _
      map_smul' := fun r y => hf.smul_right r x y }
  map_add' y z := by
    ext
    simp only [LinearMap.add_apply]
    exact hf.add_left y z x
  map_smul' r z := by
    ext
    simp only [LinearMap.smul_apply]
    exact hf.smul_left r z x

def IsLmLeftIsClmRight.toLmClm {ùïú : Type _} [NormedField ùïú] {E : Type _} [NormedAddCommGroup E]
    [NormedSpace ùïú E] {F : Type _} [NormedAddCommGroup F] [NormedSpace ùïú F] {G : Type _}
    [NormedAddCommGroup G] [NormedSpace ùïú G] {f : E √ó F ‚Üí G}
    (hf‚ÇÅ : ‚àÄ y, IsLinearMap ùïú fun a => f (a, y))
    (hf‚ÇÇ : ‚àÄ x, IsContinuousLinearMap ùïú fun a => f (x, a)) : E ‚Üí‚Çó[ùïú] F ‚ÜíL[ùïú] G
    where
  toFun x := (hf‚ÇÇ x).mk'
  map_add' y z := by
    ext
    simp only [ContinuousLinearMap.add_apply]
    exact (hf‚ÇÅ x).map_add _ _
  map_smul' r z := by
    ext
    exact (hf‚ÇÅ x).map_smul _ _

theorem IsBilinearMap.zero_left {ùïú : Type _} [NormedField ùïú] {E : Type _} [NormedAddCommGroup E]
    [NormedSpace ùïú E] {F : Type _} [NormedAddCommGroup F] [NormedSpace ùïú F] {G : Type _}
    [NormedAddCommGroup G] [NormedSpace ùïú G] {f : E √ó F ‚Üí G} (h : IsBilinearMap ùïú f) (y : F) :
    f (0, y) = 0 := by
  simp only [isBilinearMap_iff_is_linear_map_left_right] at h
  exact (h.1 y).map_zero

theorem IsBilinearMap.zero_right {ùïú : Type _} [NormedField ùïú] {E : Type _} [NormedAddCommGroup E]
    [NormedSpace ùïú E] {F : Type _} [NormedAddCommGroup F] [NormedSpace ùïú F] {G : Type _}
    [NormedAddCommGroup G] [NormedSpace ùïú G] {f : E √ó F ‚Üí G} (h : IsBilinearMap ùïú f) (x : E) :
    f (x, 0) = 0 := by
  simp only [isBilinearMap_iff_is_linear_map_left_right] at h
  exact (h.2 x).map_zero

theorem IsBilinearMap.eq_zero_add_self {ùïú : Type _} [NormedField ùïú] {E : Type _}
    [NormedAddCommGroup E] [NormedSpace ùïú E] {F : Type _} [NormedAddCommGroup F] [NormedSpace ùïú F]
    {G : Type _} [NormedAddCommGroup G] [NormedSpace ùïú G] {f : E √ó F ‚Üí G} (h : IsBilinearMap ùïú f)
    (xy : E √ó F) : f xy = f (xy.1, 0) + f xy := by simp_rw [h.zero_right, zero_add]

open scoped ComplexOrder

theorem IsContinuousLinearMap.to_is_lm {ùïú X Y : Type _} [NormedField ùïú] [NormedAddCommGroup X]
    [NormedAddCommGroup Y] [NormedSpace ùïú X] [NormedSpace ùïú Y] {Œ≤ : X ‚Üí Y}
    (hf : IsContinuousLinearMap ùïú Œ≤) : IsLinearMap ùïú Œ≤ :=
  hf.1

#print ContinuousLinearMap.op_norm_le_iff /-
theorem ContinuousLinearMap.op_norm_le_iff {ùïú X Y : Type _} [NontriviallyNormedField ùïú]
    [NormedAddCommGroup X] [NormedAddCommGroup Y] [NormedSpace ùïú X] [NormedSpace ùïú Y]
    (f : X ‚ÜíL[ùïú] Y) {r : ‚Ñù} (hr : 0 ‚â§ r) : ‚Äñf‚Äñ ‚â§ r ‚Üî ‚àÄ x, ‚Äñf x‚Äñ ‚â§ r * ‚Äñx‚Äñ :=
  by
  constructor
  ¬∑ intro hf x
    exact f.le_of_op_norm_le hf _
  ¬∑ intro h
    exact f.op_norm_le_bound hr h
-/

example
    --is_continuous_bilinear_map_norm_of_clm
    {ùïú X Y Z : Type _}
    [IsROrC ùïú] [NormedAddCommGroup X] [NormedAddCommGroup Y] [NormedAddCommGroup Z]
    [NormedSpace ùïú X] [NormedSpace ùïú Y] [NormedSpace ùïú Z] [CompleteSpace X] [CompleteSpace Y]
    [CompleteSpace Z] (Œ≤ : X ‚ÜíL[ùïú] Y ‚ÜíL[ùïú] Z) : ‚àÉ M : ‚Ñù, ‚àÄ x y, ‚ÄñŒ≤ x y‚Äñ ‚â§ M * ‚Äñx‚Äñ * ‚Äñy‚Äñ :=
  by
  use‚ÄñŒ≤‚Äñ
  intro x y
  apply ContinuousLinearMap.le_of_opNorm_le
  exact ContinuousLinearMap.le_opNorm _ _

